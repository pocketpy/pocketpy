from typing import Callable, Any, Generic, TypeVar, Literal, overload, Iterator
from linalg import vec2i

Neighborhood = Literal['Moore', 'von Neumann']

class array2d[T]:
    @property
    def n_cols(self) -> int: ...
    @property
    def n_rows(self) -> int: ...
    @property
    def width(self) -> int: ...
    @property
    def height(self) -> int: ...
    @property
    def numel(self) -> int: ...

    def __new__(cls, n_cols: int, n_rows: int, default: T | Callable[[vec2i], T] | None = None): ...
    def __eq__(self, other: object) -> array2d[bool]: ... # type: ignore
    def __ne__(self, other: object) -> array2d[bool]: ... # type: ignore
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterator[tuple[vec2i, T]]: ...

    @overload
    def is_valid(self, col: int, row: int) -> bool: ...
    @overload
    def is_valid(self, pos: vec2i) -> bool: ...

    def get[R](self, col: int, row: int, default: R = None) -> T | R:
        """Gets the value at the given position. If the position is out of bounds, return the default value."""

    @overload
    def __getitem__(self, index: tuple[int, int]) -> T: ...
    @overload
    def __getitem__(self, index: vec2i) -> T: ...
    @overload
    def __getitem__(self, index: tuple[slice, slice]) -> array2d[T]: ...
    @overload
    def __getitem__(self, mask: array2d[bool]) -> list[T]: ...
    @overload
    def __setitem__(self, index: tuple[int, int], value: T): ...
    @overload
    def __setitem__(self, index: vec2i, value: T): ...
    @overload
    def __setitem__(self, index: tuple[slice, slice], value: int | float | str | bool | None | 'array2d[T]'): ...
    @overload
    def __setitem__(self, mask: array2d[bool], value: T): ...

    def map[R](self, f: Callable[[T], R]) -> array2d[R]: ...
    def copy(self) -> 'array2d[T]': ...

    def fill_(self, value: T) -> None: ...
    def apply_(self, f: Callable[[T], T]) -> None: ...
    def copy_(self, other: array2d[T] | list[T]) -> None: ...

    def render(self) -> str: ...

    def all(self: array2d[bool]) -> bool: ...
    def any(self: array2d[bool]) -> bool: ...
    
    @staticmethod
    def fromlist(data: list[list[T]]) -> array2d[T]: ...
    def tolist(self) -> list[list[T]]: ...

    # algorithms
    def count(self, value: T) -> int:
        """Counts the number of cells with the given value."""

    def count_neighbors(self, value: T, neighborhood: Neighborhood) -> array2d[int]:
        """Counts the number of neighbors with the given value for each cell."""

    def get_bounding_rect(self, value: T) -> tuple[int, int, int, int]:
        """Gets the bounding rectangle of the given value.
        
        Returns a tuple `(x, y, width, height)` or raise `ValueError` if the value is not found.
        """

    def convolve(self: array2d[int], kernel: array2d[int], padding: int) -> array2d[int]:
        """Convolves the array with the given kernel."""

    def get_connected_components(self, value: T, neighborhood: Neighborhood) -> tuple[array2d[int], int]:
        """Gets connected components of the grid.

        Returns the `visited` array and the number of connected components,
        where `0` means unvisited, and non-zero means the index of the connected component.
        """


class array2d_view[T]:
    mask: array2d[bool] | None

    @property
    def n_cols(self) -> int: ...
    @property
    def n_rows(self) -> int: ...
    @property
    def width(self) -> int: ...
    @property
    def height(self) -> int: ...

    def __getitem__(self, index: vec2i) -> T: ...
    def __setitem__(self, index: vec2i, value: T): ...


class chunked_array2d[T]:
    def __init__(self, chunk_size: int): ...

    def __getitem__(self, index: vec2i) -> T: ...
    def __setitem__(self, index: vec2i, value: T): ...
    def __delitem__(self, index: vec2i): ...

    def get[R](self, col: int, row: int, default: R = None) -> T | R: ...

    def view(self, pos: vec2i, width: int, height: int) -> array2d_view[T]:
        """Return a view of the grid in the given rectangle."""
