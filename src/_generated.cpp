// generated by prebuild.py
#include "pocketpy/_generated.h"

namespace pkpy{
    const char kPythonLibs__enum[] = "class Enum:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __str__(self):\n        return f'{type(self).__name__}.{self.name}'\n    \n    def __repr__(self):\n        return f'<{str(self)}: {self.value!r}>'\n    \n";
    const char kPythonLibs__long[] = "# after v1.2.2, int is always 64-bit\nPyLong_SHIFT = 60//2 - 1\n\nPyLong_BASE = 2 ** PyLong_SHIFT\nPyLong_MASK = PyLong_BASE - 1\nPyLong_DECIMAL_SHIFT = 4\nPyLong_DECIMAL_BASE = 10 ** PyLong_DECIMAL_SHIFT\n\n##############################################################\n\ndef ulong_fromint(x: int):\n    # return a list of digits and sign\n    if x == 0: return [0], 1\n    sign = 1 if x > 0 else -1\n    if sign < 0: x = -x\n    res = []\n    while x:\n        res.append(x & PyLong_MASK)\n        x >>= PyLong_SHIFT\n    return res, sign\n\ndef ulong_cmp(a: list, b: list) -> int:\n    # return 1 if a>b, -1 if a<b, 0 if a==b\n    if len(a) > len(b): return 1\n    if len(a) < len(b): return -1\n    for i in range(len(a)-1, -1, -1):\n        if a[i] > b[i]: return 1\n        if a[i] < b[i]: return -1\n    return 0\n\ndef ulong_pad_(a: list, size: int):\n    # pad leading zeros to have `size` digits\n    delta = size - len(a)\n    if delta > 0:\n        a.extend([0] * delta)\n\ndef ulong_unpad_(a: list):\n    # remove leading zeros\n    while len(a)>1 and a[-1]==0:\n        a.pop()\n\ndef ulong_add(a: list, b: list) -> list:\n    res = [0] * max(len(a), len(b))\n    ulong_pad_(a, len(res))\n    ulong_pad_(b, len(res))\n    carry = 0\n    for i in range(len(res)):\n        carry += a[i] + b[i]\n        res[i] = carry & PyLong_MASK\n        carry >>= PyLong_SHIFT\n    if carry > 0:\n        res.append(carry)\n    return res\n\ndef ulong_inc_(a: list):\n    a[0] += 1\n    for i in range(len(a)):\n        if a[i] < PyLong_BASE: break\n        a[i] -= PyLong_BASE\n        if i+1 == len(a):\n            a.append(1)\n        else:\n            a[i+1] += 1\n    \n\ndef ulong_sub(a: list, b: list) -> list:\n    # a >= b\n    res = []\n    borrow = 0\n    for i in range(len(b)):\n        tmp = a[i] - b[i] - borrow\n        if tmp < 0:\n            tmp += PyLong_BASE\n            borrow = 1\n        else:\n            borrow = 0\n        res.append(tmp)\n    for i in range(len(b), len(a)):\n        tmp = a[i] - borrow\n        if tmp < 0:\n            tmp += PyLong_BASE\n            borrow = 1\n        else:\n            borrow = 0\n        res.append(tmp)\n    ulong_unpad_(res)\n    return res\n\ndef ulong_divmodi(a: list, b: int):\n    # b > 0\n    res = []\n    carry = 0\n    for i in range(len(a)-1, -1, -1):\n        carry <<= PyLong_SHIFT\n        carry += a[i]\n        res.append(carry // b)\n        carry %= b\n    res.reverse()\n    ulong_unpad_(res)\n    return res, carry\n\n\ndef ulong_divmod(a: list, b: list):\n\n    if ulong_cmp(a, b) < 0:\n        return [0], a\n\n    if len(b) == 1:\n        q, r = ulong_divmodi(a, b[0])\n        r, _ = ulong_fromint(r)\n        return q, r\n\n    max = (len(a) - len(b)) * PyLong_SHIFT + \x5c\n        (a[-1].bit_length() - b[-1].bit_length())\n\n    low = [0]\n\n    high = (max // PyLong_SHIFT) * [0] + \x5c\n        [(2**(max % PyLong_SHIFT)) & PyLong_MASK]\n\n    while ulong_cmp(low, high) < 0:\n        ulong_inc_(high)\n        mid, r = ulong_divmodi(ulong_add(low, high), 2)\n        if ulong_cmp(a, ulong_mul(b, mid)) >= 0:\n            low = mid\n        else:\n            high = ulong_sub(mid, [1])\n\n    q = [0] * (len(a) - len(b) + 1)\n    while ulong_cmp(a, ulong_mul(b, low)) >= 0:\n        q = ulong_add(q, low)\n        a = ulong_sub(a, ulong_mul(b, low))\n    ulong_unpad_(q)\n    return q, a\n\ndef ulong_floordivi(a: list, b: int):\n    # b > 0\n    return ulong_divmodi(a, b)[0]\n\ndef ulong_muli(a: list, b: int):\n    # b >= 0\n    res = [0] * len(a)\n    carry = 0\n    for i in range(len(a)):\n        carry += a[i] * b\n        res[i] = carry & PyLong_MASK\n        carry >>= PyLong_SHIFT\n    if carry > 0:\n        res.append(carry)\n    return res\n\ndef ulong_mul(a: list, b: list):\n    N = len(a) + len(b)\n    # use grade-school multiplication\n    res = [0] * N\n    for i in range(len(a)):\n        carry = 0\n        for j in range(len(b)):\n            carry += res[i+j] + a[i] * b[j]\n            res[i+j] = carry & PyLong_MASK\n            carry >>= PyLong_SHIFT\n        res[i+len(b)] = carry\n    ulong_unpad_(res)\n    return res\n\ndef ulong_powi(a: list, b: int):\n    # b >= 0\n    if b == 0: return [1]\n    res = [1]\n    while b:\n        if b & 1:\n            res = ulong_mul(res, a)\n        a = ulong_mul(a, a)\n        b >>= 1\n    return res\n\ndef ulong_repr(x: list) -> str:\n    res = []\n    while len(x)>1 or x[0]>0:   # non-zero\n        x, r = ulong_divmodi(x, PyLong_DECIMAL_BASE)\n        res.append(str(r).zfill(PyLong_DECIMAL_SHIFT))\n    res.reverse()\n    s = ''.join(res)\n    if len(s) == 0: return '0'\n    if len(s) > 1: s = s.lstrip('0')\n    return s\n\ndef ulong_fromstr(s: str):\n    if s[-1] == 'L':\n        s = s[:-1]\n    res, base = [0], [1]\n    if s[0] == '-':\n        sign = -1\n        s = s[1:]\n    else:\n        sign = 1\n    s = s[::-1]\n    for c in s:\n        c = ord(c) - 48\n        assert 0 <= c <= 9\n        res = ulong_add(res, ulong_muli(base, c))\n        base = ulong_muli(base, 10)\n    return res, sign\n\nclass long:\n    def __init__(self, x):\n        if type(x) is tuple:\n            self.digits, self.sign = x\n        elif type(x) is int:\n            self.digits, self.sign = ulong_fromint(x)\n        elif type(x) is float:\n            self.digits, self.sign = ulong_fromint(int(x))\n        elif type(x) is str:\n            self.digits, self.sign = ulong_fromstr(x)\n        elif type(x) is long:\n            self.digits, self.sign = x.digits.copy(), x.sign\n        else:\n            raise TypeError('expected int or str')\n        \n    def __len__(self):\n        return len(self.digits)\n\n    def __add__(self, other):\n        if type(other) is int:\n            other = long(other)\n        elif type(other) is not long:\n            return NotImplemented\n        if self.sign == other.sign:\n            return long((ulong_add(self.digits, other.digits), self.sign))\n        else:\n            cmp = ulong_cmp(self.digits, other.digits)\n            if cmp == 0:\n                return long(0)\n            if cmp > 0:\n                return long((ulong_sub(self.digits, other.digits), self.sign))\n            else:\n                return long((ulong_sub(other.digits, self.digits), other.sign))\n            \n    def __radd__(self, other):\n        return self.__add__(other)\n    \n    def __sub__(self, other):\n        if type(other) is int:\n            other = long(other)\n        elif type(other) is not long:\n            return NotImplemented\n        if self.sign != other.sign:\n            return long((ulong_add(self.digits, other.digits), self.sign))\n        cmp = ulong_cmp(self.digits, other.digits)\n        if cmp == 0:\n            return long(0)\n        if cmp > 0:\n            return long((ulong_sub(self.digits, other.digits), self.sign))\n        else:\n            return long((ulong_sub(other.digits, self.digits), -other.sign))\n            \n    def __rsub__(self, other):\n        if type(other) is int:\n            other = long(other)\n        elif type(other) is not long:\n            return NotImplemented\n        return other.__sub__(self)\n    \n    def __mul__(self, other):\n        if type(other) is int:\n            return long((\n                ulong_muli(self.digits, abs(other)),\n                self.sign * (1 if other >= 0 else -1)\n            ))\n        elif type(other) is long:\n            return long((\n                ulong_mul(self.digits, other.digits),\n                self.sign * other.sign\n            ))\n        return NotImplemented\n    \n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    #######################################################\n    def __divmod__(self, other):\n        if type(other) is int:\n            assert self.sign == 1 and other > 0\n            q, r = ulong_divmodi(self.digits, other)\n            return long((q, 1)), r\n        if type(other) is long:\n            assert self.sign == 1 and other.sign == 1\n            q, r = ulong_divmod(self.digits, other.digits)\n            assert len(other)>1 or other.digits[0]>0\n            return long((q, 1)), long((r, 1))\n        raise NotImplementedError\n\n    def __floordiv__(self, other):\n        return self.__divmod__(other)[0]\n\n    def __mod__(self, other):\n        return self.__divmod__(other)[1]\n\n    def __pow__(self, other: int):\n        assert type(other) is int and other >= 0\n        if self.sign == -1 and other & 1:\n            sign = -1\n        else:\n            sign = 1\n        return long((ulong_powi(self.digits, other), sign))\n    \n    def __lshift__(self, other: int):\n        assert type(other) is int and other >= 0\n        x = self.digits.copy()\n        q, r = divmod(other, PyLong_SHIFT)\n        x = [0]*q + x\n        for _ in range(r): x = ulong_muli(x, 2)\n        return long((x, self.sign))\n    \n    def __rshift__(self, other: int):\n        assert type(other) is int and other >= 0\n        x = self.digits.copy()\n        q, r = divmod(other, PyLong_SHIFT)\n        x = x[q:]\n        if not x: return long(0)\n        for _ in range(r): x = ulong_floordivi(x, 2)\n        return long((x, self.sign))\n    \n    def __neg__(self):\n        return long((self.digits, -self.sign))\n    \n    def __cmp__(self, other):\n        if type(other) is int:\n            other = long(other)\n        elif type(other) is not long:\n            return NotImplemented\n        if self.sign > other.sign:\n            return 1\n        elif self.sign < other.sign:\n            return -1\n        else:\n            return ulong_cmp(self.digits, other.digits)\n        \n    def __eq__(self, other):\n        return self.__cmp__(other) == 0\n    def __lt__(self, other):\n        return self.__cmp__(other) < 0\n    def __le__(self, other):\n        return self.__cmp__(other) <= 0\n    def __gt__(self, other):\n        return self.__cmp__(other) > 0\n    def __ge__(self, other):\n        return self.__cmp__(other) >= 0\n            \n    def __repr__(self):\n        prefix = '-' if self.sign < 0 else ''\n        return prefix + ulong_repr(self.digits) + 'L'\n";
    const char kPythonLibs__set[] = "class set:\n    def __init__(self, iterable=None):\n        iterable = iterable or []\n        self._a = {}\n        self.update(iterable)\n\n    def add(self, elem):\n        self._a[elem] = None\n        \n    def discard(self, elem):\n        self._a.pop(elem, None)\n\n    def remove(self, elem):\n        del self._a[elem]\n        \n    def clear(self):\n        self._a.clear()\n\n    def update(self, other):\n        for elem in other:\n            self.add(elem)\n\n    def __len__(self):\n        return len(self._a)\n    \n    def copy(self):\n        return set(self._a.keys())\n    \n    def __and__(self, other):\n        return {elem for elem in self if elem in other}\n\n    def __sub__(self, other):\n        return {elem for elem in self if elem not in other}\n    \n    def __or__(self, other):\n        ret = self.copy()\n        ret.update(other)\n        return ret\n\n    def __xor__(self, other): \n        _0 = self - other\n        _1 = other - self\n        return _0 | _1\n\n    def union(self, other):\n        return self | other\n\n    def intersection(self, other):\n        return self & other\n\n    def difference(self, other):\n        return self - other\n\n    def symmetric_difference(self, other):      \n        return self ^ other\n    \n    def __eq__(self, other):\n        if not isinstance(other, set):\n            return NotImplemented\n        return len(self ^ other) == 0\n\n    def isdisjoint(self, other):\n        return len(self & other) == 0\n    \n    def issubset(self, other):\n        return len(self - other) == 0\n    \n    def issuperset(self, other):\n        return len(other - self) == 0\n\n    def __contains__(self, elem):\n        return elem in self._a\n    \n    def __repr__(self):\n        if len(self) == 0:\n            return 'set()'\n        return '{'+ ', '.join([repr(i) for i in self._a.keys()]) + '}'\n    \n    def __iter__(self):\n        return iter(self._a.keys())";
    const char kPythonLibs_bisect[] = "\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    lo = bisect_right(a, x, lo, hi)\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    lo = bisect_left(a, x, lo, hi)\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n";
    const char kPythonLibs_builtins[] = "from __builtins import next as __builtins_next\n\ndef all(iterable):\n    for i in iterable:\n        if not i:\n            return False\n    return True\n\ndef any(iterable):\n    for i in iterable:\n        if i:\n            return True\n    return False\n\ndef enumerate(iterable, start=0):\n    n = start\n    for elem in iterable:\n        yield n, elem\n        ++n\n\ndef sum(iterable):\n    res = 0\n    for i in iterable:\n        res += i\n    return res\n\ndef map(f, iterable):\n    for i in iterable:\n        yield f(i)\n\ndef filter(f, iterable):\n    for i in iterable:\n        if f(i):\n            yield i\n\ndef zip(a, b):\n    a = iter(a)\n    b = iter(b)\n    while True:\n        ai = __builtins_next(a)\n        bi = __builtins_next(b)\n        if ai is StopIteration or bi is StopIteration:\n            break\n        yield ai, bi\n\ndef reversed(iterable):\n    a = list(iterable)\n    a.reverse()\n    return a\n\ndef sorted(iterable, key=None, reverse=False):\n    a = list(iterable)\n    a.sort(key=key, reverse=reverse)\n    return a\n\n##### str #####\ndef __format_string(self: str, *args, **kwargs) -> str:\n    def tokenizeString(s: str):\n        tokens = []\n        L, R = 0,0\n        \n        mode = None\n        curArg = 0\n        # lookingForKword = False\n        \n        while(R<len(s)):\n            curChar = s[R]\n            nextChar = s[R+1] if R+1<len(s) else ''\n            \n            # Invalid case 1: stray '}' encountered, example: \"ABCD EFGH {name} IJKL}\", \"Hello {vv}}\", \"HELLO {0} WORLD}\"\n            if curChar == '}' and nextChar != '}':\n                raise ValueError(\"Single '}' encountered in format string\")        \n            \n            # Valid Case 1: Escaping case, we escape \"{{ or \"}}\" to be \"{\" or \"}\", example: \"{{}}\", \"{{My Name is {0}}}\"\n            if (curChar == '{' and nextChar == '{') or (curChar == '}' and nextChar == '}'):\n                \n                if (L<R): # Valid Case 1.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the escape\n                \n                \n                tokens.append(curChar) # Valid Case 1.2: add the escape char\n                L = R+2 # move the left pointer to the next char\n                R = R+2 # move the right pointer to the next char\n                continue\n            \n            # Valid Case 2: Regular command line arg case: example:  \"ABCD EFGH {} IJKL\", \"{}\", \"HELLO {} WORLD\"\n            elif curChar == '{' and nextChar == '}':\n                if mode is not None and mode != 'auto':\n                    # Invalid case 2: mixing automatic and manual field specifications -- example: \"ABCD EFGH {name} IJKL {}\", \"Hello {vv} {}\", \"HELLO {0} WORLD {}\" \n                    raise ValueError(\"Cannot switch from manual field numbering to automatic field specification\")\n                \n                mode = 'auto'\n                if(L<R): # Valid Case 2.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the special marker for the arg\n                \n                tokens.append(\"{\"+str(curArg)+\"}\") # Valid Case 2.2: add the special marker for the arg\n                curArg+=1 # increment the arg position, this will be used for referencing the arg later\n                \n                L = R+2 # move the left pointer to the next char\n                R = R+2 # move the right pointer to the next char\n                continue\n            \n            # Valid Case 3: Key-word arg case: example: \"ABCD EFGH {name} IJKL\", \"Hello {vv}\", \"HELLO {name} WORLD\"\n            elif (curChar == '{'):\n                \n                if mode is not None and mode != 'manual':\n                    # # Invalid case 2: mixing automatic and manual field specifications -- example: \"ABCD EFGH {} IJKL {name}\", \"Hello {} {1}\", \"HELLO {} WORLD {name}\"\n                    raise ValueError(\"Cannot switch from automatic field specification to manual field numbering\")\n                \n                mode = 'manual'\n                \n                if(L<R): # Valid case 3.1: make sure we are not adding empty string\n                    tokens.append(s[L:R]) # add the string before the special marker for the arg\n                \n                # We look for the end of the keyword          \n                kwL = R # Keyword left pointer\n                kwR = R+1 # Keyword right pointer\n                while(kwR<len(s) and s[kwR]!='}'):\n                    if s[kwR] == '{': # Invalid case 3: stray '{' encountered, example: \"ABCD EFGH {n{ame} IJKL {\", \"Hello {vv{}}\", \"HELLO {0} WOR{LD}\"\n                        raise ValueError(\"Unexpected '{' in field name\")\n                    kwR += 1\n                \n                # Valid case 3.2: We have successfully found the end of the keyword\n                if kwR<len(s) and s[kwR] == '}':\n                    tokens.append(s[kwL:kwR+1]) # add the special marker for the arg\n                    L = kwR+1\n                    R = kwR+1\n                    \n                # Invalid case 4: We didn't find the end of the keyword, throw error\n                else:\n                    raise ValueError(\"Expected '}' before end of string\")\n                continue\n            \n            R = R+1\n        \n        \n        # Valid case 4: We have reached the end of the string, add the remaining string to the tokens \n        if L<R:\n            tokens.append(s[L:R])\n                \n        # print(tokens)\n        return tokens\n\n    tokens = tokenizeString(self)\n    argMap = {}\n    for i, a in enumerate(args):\n        argMap[str(i)] = a\n    final_tokens = []\n    for t in tokens:\n        if t[0] == '{' and t[-1] == '}':\n            key = t[1:-1]\n            argMapVal = argMap.get(key, None)\n            kwargsVal = kwargs.get(key, None)\n                                    \n            if argMapVal is None and kwargsVal is None:\n                raise ValueError(\"No arg found for token: \"+t)\n            elif argMapVal is not None:\n                final_tokens.append(str(argMapVal))\n            else:\n                final_tokens.append(str(kwargsVal))\n        else:\n            final_tokens.append(t)\n    \n    return ''.join(final_tokens)\n\nstr.format = __format_string\ndel __format_string\n\n\ndef help(obj):\n    if hasattr(obj, '__func__'):\n        obj = obj.__func__\n    print(obj.__signature__)\n    print(obj.__doc__)\n\ndef complex(*args, **kwargs):\n    import cmath\n    return cmath.complex(*args, **kwargs)\n\ndef long(*args, **kwargs):\n    import _long\n    return _long.long(*args, **kwargs)\n\n\n# builtin exceptions\nclass StackOverflowError(Exception): pass\nclass IOError(Exception): pass\nclass NotImplementedError(Exception): pass\nclass TypeError(Exception): pass\nclass IndexError(Exception): pass\nclass ValueError(Exception): pass\nclass RuntimeError(Exception): pass\nclass ZeroDivisionError(Exception): pass\nclass NameError(Exception): pass\nclass UnboundLocalError(Exception): pass\nclass AttributeError(Exception): pass\nclass ImportError(Exception): pass\nclass AssertionError(Exception): pass\n\nclass KeyError(Exception):\n    def __init__(self, key=...):\n        self.key = key\n        if key is ...:\n            super().__init__()\n        else:\n            super().__init__(repr(key))\n\n    def __str__(self):\n        if self.key is ...:\n            return ''\n        return str(self.key)\n    \n    def __repr__(self):\n        if self.key is ...:\n            return 'KeyError()'\n        return f'KeyError({self.key!r})'\n\nclass SystemExit(Exception):\n    def __init__(self, code=None):\n        self.code = code\n";
    const char kPythonLibs_cmath[] = "import math\n\nclass complex:\n    def __init__(self, real, imag=0):\n        self._real = float(real)\n        self._imag = float(imag)\n\n    @property\n    def real(self):\n        return self._real\n    \n    @property\n    def imag(self):\n        return self._imag\n\n    def conjugate(self):\n        return complex(self.real, -self.imag)\n    \n    def __repr__(self):\n        s = ['(', str(self.real)]\n        s.append('-' if self.imag < 0 else '+')\n        s.append(str(abs(self.imag)))\n        s.append('j)')\n        return ''.join(s)\n    \n    def __eq__(self, other):\n        if type(other) is complex:\n            return self.real == other.real and self.imag == other.imag\n        if type(other) in (int, float):\n            return self.real == other and self.imag == 0\n        return NotImplemented\n    \n    def __add__(self, other):\n        if type(other) is complex:\n            return complex(self.real + other.real, self.imag + other.imag)\n        if type(other) in (int, float):\n            return complex(self.real + other, self.imag)\n        return NotImplemented\n        \n    def __radd__(self, other):\n        return self.__add__(other)\n    \n    def __sub__(self, other):\n        if type(other) is complex:\n            return complex(self.real - other.real, self.imag - other.imag)\n        if type(other) in (int, float):\n            return complex(self.real - other, self.imag)\n        return NotImplemented\n    \n    def __rsub__(self, other):\n        if type(other) is complex:\n            return complex(other.real - self.real, other.imag - self.imag)\n        if type(other) in (int, float):\n            return complex(other - self.real, -self.imag)\n        return NotImplemented\n    \n    def __mul__(self, other):\n        if type(other) is complex:\n            return complex(self.real * other.real - self.imag * other.imag,\n                           self.real * other.imag + self.imag * other.real)\n        if type(other) in (int, float):\n            return complex(self.real * other, self.imag * other)\n        return NotImplemented\n    \n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __truediv__(self, other):\n        if type(other) is complex:\n            denominator = other.real ** 2 + other.imag ** 2\n            real_part = (self.real * other.real + self.imag * other.imag) / denominator\n            imag_part = (self.imag * other.real - self.real * other.imag) / denominator\n            return complex(real_part, imag_part)\n        if type(other) in (int, float):\n            return complex(self.real / other, self.imag / other)\n        return NotImplemented\n    \n    def __pow__(self, other: int | float):\n        if type(other) in (int, float):\n            return complex(self.__abs__() ** other * math.cos(other * phase(self)),\n                           self.__abs__() ** other * math.sin(other * phase(self)))\n        return NotImplemented\n    \n    def __abs__(self) -> float:\n        return math.sqrt(self.real ** 2 + self.imag ** 2)\n\n    def __neg__(self):\n        return complex(-self.real, -self.imag)\n    \n    def __hash__(self):\n        return hash((self.real, self.imag))\n\n\n# Conversions to and from polar coordinates\n\ndef phase(z: complex):\n    return math.atan2(z.imag, z.real)\n\ndef polar(z: complex):\n    return z.__abs__(), phase(z)\n\ndef rect(r: float, phi: float):\n    return r * math.cos(phi) + r * math.sin(phi) * 1j\n\n# Power and logarithmic functions\n\ndef exp(z: complex):\n    return math.exp(z.real) * rect(1, z.imag)\n\ndef log(z: complex, base=2.718281828459045):\n    return math.log(z.__abs__(), base) + phase(z) * 1j\n\ndef log10(z: complex):\n    return log(z, 10)\n\ndef sqrt(z: complex):\n    return z ** 0.5\n\n# Trigonometric functions\n\ndef acos(z: complex):\n    return -1j * log(z + sqrt(z * z - 1))\n\ndef asin(z: complex):\n    return -1j * log(1j * z + sqrt(1 - z * z))\n\ndef atan(z: complex):\n    return 1j / 2 * log((1 - 1j * z) / (1 + 1j * z))\n\ndef cos(z: complex):\n    return (exp(z) + exp(-z)) / 2\n\ndef sin(z: complex):\n    return (exp(z) - exp(-z)) / (2 * 1j)\n\ndef tan(z: complex):\n    return sin(z) / cos(z)\n\n# Hyperbolic functions\n\ndef acosh(z: complex):\n    return log(z + sqrt(z * z - 1))\n\ndef asinh(z: complex):\n    return log(z + sqrt(z * z + 1))\n\ndef atanh(z: complex):\n    return 1 / 2 * log((1 + z) / (1 - z))\n\ndef cosh(z: complex):\n    return (exp(z) + exp(-z)) / 2\n\ndef sinh(z: complex):\n    return (exp(z) - exp(-z)) / 2\n\ndef tanh(z: complex):\n    return sinh(z) / cosh(z)\n\n# Classification functions\n\ndef isfinite(z: complex):\n    return math.isfinite(z.real) and math.isfinite(z.imag)\n\ndef isinf(z: complex):\n    return math.isinf(z.real) or math.isinf(z.imag)\n\ndef isnan(z: complex):\n    return math.isnan(z.real) or math.isnan(z.imag)\n\ndef isclose(a: complex, b: complex):\n    return math.isclose(a.real, b.real) and math.isclose(a.imag, b.imag)\n\n# Constants\n\npi = math.pi\ne = math.e\ntau = 2 * pi\ninf = math.inf\ninfj = complex(0, inf)\nnan = math.nan\nnanj = complex(0, nan)\n";
    const char kPythonLibs_collections[] = "def Counter(iterable):\n    a = {}\n    for x in iterable:\n        if x in a:\n            a[x] += 1\n        else:\n            a[x] = 1\n    return a\n\nfrom __builtins import _enable_instance_dict\n\nclass defaultdict(dict):\n    def __init__(self, default_factory, *args):\n        super().__init__(*args)\n        _enable_instance_dict(self)\n        self.default_factory = default_factory\n\n    def __missing__(self, key):\n        self[key] = self.default_factory()\n        return self[key]\n\n    def __repr__(self) -> str:\n        return f\"defaultdict({self.default_factory}, {super().__repr__()})\"\n\n    def copy(self):\n        return defaultdict(self.default_factory, self)\n\n";
    const char kPythonLibs_colorsys[] = "\"\"\"Conversion functions between RGB and other color systems.\n\nThis modules provides two functions for each color system ABC:\n\n  rgb_to_abc(r, g, b) --> a, b, c\n  abc_to_rgb(a, b, c) --> r, g, b\n\nAll inputs and outputs are triples of floats in the range [0.0...1.0]\n(with the exception of I and Q, which covers a slightly larger range).\nInputs outside the valid range may cause exceptions or invalid outputs.\n\nSupported color systems:\nRGB: Red, Green, Blue components\nYIQ: Luminance, Chrominance (used by composite video signals)\nHLS: Hue, Luminance, Saturation\nHSV: Hue, Saturation, Value\n\"\"\"\n\n# References:\n# http://en.wikipedia.org/wiki/YIQ\n# http://en.wikipedia.org/wiki/HLS_color_space\n# http://en.wikipedia.org/wiki/HSV_color_space\n\n__all__ = [\"rgb_to_yiq\",\"yiq_to_rgb\",\"rgb_to_hls\",\"hls_to_rgb\",\n           \"rgb_to_hsv\",\"hsv_to_rgb\"]\n\n# Some floating point constants\n\nONE_THIRD = 1.0/3.0\nONE_SIXTH = 1.0/6.0\nTWO_THIRD = 2.0/3.0\n\n# YIQ: used by composite video signals (linear combinations of RGB)\n# Y: perceived grey level (0.0 == black, 1.0 == white)\n# I, Q: color components\n#\n# There are a great many versions of the constants used in these formulae.\n# The ones in this library uses constants from the FCC version of NTSC.\n\ndef rgb_to_yiq(r, g, b):\n    y = 0.30*r + 0.59*g + 0.11*b\n    i = 0.74*(r-y) - 0.27*(b-y)\n    q = 0.48*(r-y) + 0.41*(b-y)\n    return (y, i, q)\n\ndef yiq_to_rgb(y, i, q):\n    # r = y + (0.27*q + 0.41*i) / (0.74*0.41 + 0.27*0.48)\n    # b = y + (0.74*q - 0.48*i) / (0.74*0.41 + 0.27*0.48)\n    # g = y - (0.30*(r-y) + 0.11*(b-y)) / 0.59\n\n    r = y + 0.9468822170900693*i + 0.6235565819861433*q\n    g = y - 0.27478764629897834*i - 0.6356910791873801*q\n    b = y - 1.1085450346420322*i + 1.7090069284064666*q\n\n    if r < 0.0:\n        r = 0.0\n    if g < 0.0:\n        g = 0.0\n    if b < 0.0:\n        b = 0.0\n    if r > 1.0:\n        r = 1.0\n    if g > 1.0:\n        g = 1.0\n    if b > 1.0:\n        b = 1.0\n    return (r, g, b)\n\n\n# HLS: Hue, Luminance, Saturation\n# H: position in the spectrum\n# L: color lightness\n# S: color saturation\n\ndef rgb_to_hls(r, g, b):\n    maxc = max(r, g, b)\n    minc = min(r, g, b)\n    sumc = (maxc+minc)\n    rangec = (maxc-minc)\n    l = sumc/2.0\n    if minc == maxc:\n        return 0.0, l, 0.0\n    if l <= 0.5:\n        s = rangec / sumc\n    else:\n        s = rangec / (2.0-maxc-minc)  # Not always 2.0-sumc: gh-106498.\n    rc = (maxc-r) / rangec\n    gc = (maxc-g) / rangec\n    bc = (maxc-b) / rangec\n    if r == maxc:\n        h = bc-gc\n    elif g == maxc:\n        h = 2.0+rc-bc\n    else:\n        h = 4.0+gc-rc\n    # h = (h/6.0) % 1.0\n    h = h / 6.0\n    h = h - int(h)\n    return h, l, s\n\ndef hls_to_rgb(h, l, s):\n    if s == 0.0:\n        return l, l, l\n    if l <= 0.5:\n        m2 = l * (1.0+s)\n    else:\n        m2 = l+s-(l*s)\n    m1 = 2.0*l - m2\n    return (_v(m1, m2, h+ONE_THIRD), _v(m1, m2, h), _v(m1, m2, h-ONE_THIRD))\n\ndef _v(m1, m2, hue):\n    # hue = hue % 1.0\n    hue = hue - int(hue)\n    if hue < ONE_SIXTH:\n        return m1 + (m2-m1)*hue*6.0\n    if hue < 0.5:\n        return m2\n    if hue < TWO_THIRD:\n        return m1 + (m2-m1)*(TWO_THIRD-hue)*6.0\n    return m1\n\n\n# HSV: Hue, Saturation, Value\n# H: position in the spectrum\n# S: color saturation (\"purity\")\n# V: color brightness\n\ndef rgb_to_hsv(r, g, b):\n    maxc = max(r, g, b)\n    minc = min(r, g, b)\n    rangec = (maxc-minc)\n    v = maxc\n    if minc == maxc:\n        return 0.0, 0.0, v\n    s = rangec / maxc\n    rc = (maxc-r) / rangec\n    gc = (maxc-g) / rangec\n    bc = (maxc-b) / rangec\n    if r == maxc:\n        h = bc-gc\n    elif g == maxc:\n        h = 2.0+rc-bc\n    else:\n        h = 4.0+gc-rc\n    # h = (h/6.0) % 1.0\n    h = h / 6.0\n    h = h - int(h)\n    return h, s, v\n\ndef hsv_to_rgb(h, s, v):\n    if s == 0.0:\n        return v, v, v\n    i = int(h*6.0) # XXX assume int() truncates!\n    f = (h*6.0) - i\n    p = v*(1.0 - s)\n    q = v*(1.0 - s*f)\n    t = v*(1.0 - s*(1.0-f))\n    i = i%6\n    if i == 0:\n        return v, t, p\n    if i == 1:\n        return q, v, p\n    if i == 2:\n        return p, v, t\n    if i == 3:\n        return p, q, v\n    if i == 4:\n        return t, p, v\n    if i == 5:\n        return v, p, q\n    # Cannot get here";
    const char kPythonLibs_datetime[] = "from time import localtime\n\nclass timedelta:\n    def __init__(self, days=0, seconds=0):\n        self.days = days\n        self.seconds = seconds\n\n    def __repr__(self):\n        return f\"datetime.timedelta(days={self.days}, seconds={self.seconds})\"\n\n    def __eq__(self, other: 'timedelta') -> bool:\n        if type(other) is not timedelta:\n            return NotImplemented\n        return (self.days, self.seconds) == (other.days, other.seconds)\n\n    def __lt__(self, other: 'timedelta') -> bool:\n        if type(other) is not timedelta:\n            return NotImplemented\n        return (self.days, self.seconds) < (other.days, other.seconds)\n\n    def __le__(self, other: 'timedelta') -> bool:\n        if type(other) is not timedelta:\n            return NotImplemented\n        return (self.days, self.seconds) <= (other.days, other.seconds)\n\n    def __gt__(self, other: 'timedelta') -> bool:\n        if type(other) is not timedelta:\n            return NotImplemented\n        return (self.days, self.seconds) > (other.days, other.seconds)\n\n    def __ge__(self, other: 'timedelta') -> bool:\n        if type(other) is not timedelta:\n            return NotImplemented\n        return (self.days, self.seconds) >= (other.days, other.seconds)\n\n\nclass date:\n    def __init__(self, year: int, month: int, day: int):\n        self.year = year\n        self.month = month\n        self.day = day\n\n    @staticmethod\n    def today():\n        t = localtime()\n        return date(t.tm_year, t.tm_mon, t.tm_mday)\n\n    def __eq__(self, other: 'date') -> bool:\n        if type(other) is not date:\n            return NotImplemented\n        return (self.year, self.month, self.day) == (other.year, other.month, other.day)\n\n    def __lt__(self, other: 'date') -> bool:\n        if type(other) is not date:\n            return NotImplemented\n        return (self.year, self.month, self.day) < (other.year, other.month, other.day)\n\n    def __le__(self, other: 'date') -> bool:\n        if type(other) is not date:\n            return NotImplemented\n        return (self.year, self.month, self.day) <= (other.year, other.month, other.day)\n\n    def __gt__(self, other: 'date') -> bool:\n        if type(other) is not date:\n            return NotImplemented\n        return (self.year, self.month, self.day) > (other.year, other.month, other.day)\n\n    def __ge__(self, other: 'date') -> bool:\n        if type(other) is not date:\n            return NotImplemented\n        return (self.year, self.month, self.day) >= (other.year, other.month, other.day)\n\n    def __str__(self):\n        return f\"{self.year}-{self.month:02}-{self.day:02}\"\n\n    def __repr__(self):\n        return f\"datetime.date({self.year}, {self.month}, {self.day})\"\n\n\nclass datetime(date):\n    def __init__(self, year: int, month: int, day: int, hour: int, minute: int, second: int):\n        super().__init__(year, month, day)\n        # Validate and set hour, minute, and second\n        if not 0 <= hour <= 23:\n            raise ValueError(\"Hour must be between 0 and 23\")\n        self.hour = hour\n        if not 0 <= minute <= 59:\n            raise ValueError(\"Minute must be between 0 and 59\")\n        self.minute = minute\n        if not 0 <= second <= 59:\n            raise ValueError(\"Second must be between 0 and 59\")\n        self.second = second\n\n    def date(self) -> date:\n        return date(self.year, self.month, self.day)\n\n    @staticmethod\n    def now():\n        t = localtime()\n        tm_sec = t.tm_sec\n        if tm_sec == 60:\n            tm_sec = 59\n        return datetime(t.tm_year, t.tm_mon, t.tm_mday, t.tm_hour, t.tm_min, tm_sec)\n\n    def __str__(self):\n        return f\"{self.year}-{self.month:02}-{self.day:02} {self.hour:02}:{self.minute:02}:{self.second:02}\"\n\n    def __repr__(self):\n        return f\"datetime.datetime({self.year}, {self.month}, {self.day}, {self.hour}, {self.minute}, {self.second})\"\n\n    def __eq__(self, other) -> bool:\n        if type(other) is not datetime:\n            return NotImplemented\n        return (self.year, self.month, self.day, self.hour, self.minute, self.second) ==\x5c\n            (other.year, other.month, other.day,\n             other.hour, other.minute, other.second)\n\n    def __lt__(self, other) -> bool:\n        if type(other) is not datetime:\n            return NotImplemented\n        return (self.year, self.month, self.day, self.hour, self.minute, self.second) <\x5c\n            (other.year, other.month, other.day,\n             other.hour, other.minute, other.second)\n\n    def __le__(self, other) -> bool:\n        if type(other) is not datetime:\n            return NotImplemented\n        return (self.year, self.month, self.day, self.hour, self.minute, self.second) <=\x5c\n            (other.year, other.month, other.day,\n             other.hour, other.minute, other.second)\n\n    def __gt__(self, other) -> bool:\n        if type(other) is not datetime:\n            return NotImplemented\n        return (self.year, self.month, self.day, self.hour, self.minute, self.second) >\x5c\n            (other.year, other.month, other.day,\n             other.hour, other.minute, other.second)\n\n    def __ge__(self, other) -> bool:\n        if type(other) is not datetime:\n            return NotImplemented\n        return (self.year, self.month, self.day, self.hour, self.minute, self.second) >=\x5c\n            (other.year, other.month, other.day,\n             other.hour, other.minute, other.second)\n\n    def timestamp(self) -> float:\n        raise NotImplementedError\n\n";
    const char kPythonLibs_functools[] = "from __builtins import next\n\nclass cache:\n    def __init__(self, f):\n        self.f = f\n        self.cache = {}\n\n    def __call__(self, *args):\n        if args not in self.cache:\n            self.cache[args] = self.f(*args)\n        return self.cache[args]\n    \ndef reduce(function, sequence, initial=...):\n    it = iter(sequence)\n    if initial is ...:\n        value = next(it)\n        if value is StopIteration:\n            raise TypeError(\"reduce() of empty iterable with no initial value\")\n    else:\n        value = initial\n    for element in it:\n        value = function(value, element)\n    return value\n\nclass partial:\n    def __init__(self, f, *args, **kwargs):\n        self.f = f\n        if not callable(f):\n            raise TypeError(\"the first argument must be callable\")\n        self.args = args\n        self.kwargs = kwargs\n\n    def __call__(self, *args, **kwargs):\n        kwargs.update(self.kwargs)\n        return self.f(*self.args, *args, **kwargs)\n\n";
    const char kPythonLibs_heapq[] = "# Heap queue algorithm (a.k.a. priority queue)\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap)-1)\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\ndef heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup(heap, 0)\n    return returnitem\n\ndef heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\n\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n//2)):\n        _siftup(x, i)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2*pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2*pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)";
    const char kPythonLibs_itertools[] = "from __builtins import next\n\ndef zip_longest(a, b):\n    a = iter(a)\n    b = iter(b)\n    while True:\n        ai = next(a)\n        bi = next(b)\n        if ai is StopIteration and bi is StopIteration:\n            break\n        if ai is StopIteration:\n            ai = None\n        if bi is StopIteration:\n            bi = None\n        yield ai, bi\n";
    const char kPythonLibs_operator[] = "# https://docs.python.org/3/library/operator.html#mapping-operators-to-functions\n\ndef le(a, b): return a <= b\ndef lt(a, b): return a < b\ndef ge(a, b): return a >= b\ndef gt(a, b): return a > b\ndef eq(a, b): return a == b\ndef ne(a, b): return a != b\n\ndef and_(a, b): return a & b\ndef or_(a, b): return a | b\ndef xor(a, b): return a ^ b\ndef invert(a): return ~a\ndef lshift(a, b): return a << b\ndef rshift(a, b): return a >> b\n\ndef is_(a, b): return a is b\ndef is_not(a, b): return a is not b\ndef not_(a): return not a\ndef truth(a): return bool(a)\ndef contains(a, b): return b in a\n\ndef add(a, b): return a + b\ndef sub(a, b): return a - b\ndef mul(a, b): return a * b\ndef truediv(a, b): return a / b\ndef floordiv(a, b): return a // b\ndef mod(a, b): return a % b\ndef pow(a, b): return a ** b\ndef neg(a): return -a\ndef matmul(a, b): return a @ b\n\ndef getitem(a, b): return a[b]\ndef setitem(a, b, c): a[b] = c\ndef delitem(a, b): del a[b]\n\ndef iadd(a, b): a += b; return a\ndef isub(a, b): a -= b; return a\ndef imul(a, b): a *= b; return a\ndef itruediv(a, b): a /= b; return a\ndef ifloordiv(a, b): a //= b; return a\ndef imod(a, b): a %= b; return a\n# def ipow(a, b): a **= b; return a\n# def imatmul(a, b): a @= b; return a\ndef iand(a, b): a &= b; return a\ndef ior(a, b): a |= b; return a\ndef ixor(a, b): a ^= b; return a\ndef ilshift(a, b): a <<= b; return a\ndef irshift(a, b): a >>= b; return a\n";
    const char kPythonLibs_pickle[] = "import json\nfrom c import struct\nimport builtins\n\n_BASIC_TYPES = [int, float, str, bool, type(None)]\n_MOD_T_SEP = \"@\"\n\ndef _find_class(path: str):\n    if _MOD_T_SEP not in path:\n        return builtins.__dict__[path]\n    modpath, name = path.split(_MOD_T_SEP)\n    return __import__(modpath).__dict__[name]\n\nclass _Pickler:\n    def __init__(self, obj) -> None:\n        self.obj = obj\n        self.raw_memo = {}  # id -> int\n        self.memo = []      # int -> object\n\n    @staticmethod\n    def _type_id(t: type):\n        assert type(t) is type\n        name = t.__name__\n        mod = t.__module__\n        if mod is not None:\n            name = mod.__path__ + _MOD_T_SEP + name\n        return name\n\n    def wrap(self, o):\n        o_t = type(o)\n        if o_t in _BASIC_TYPES:\n            return o\n        if o_t is type:\n            return [\"type\", self._type_id(o)]\n\n        index = self.raw_memo.get(id(o), None)\n        if index is not None:\n            return [index]\n        \n        ret = []\n        index = len(self.memo)\n        self.memo.append(ret)\n        self.raw_memo[id(o)] = index\n\n        if o_t is tuple:\n            ret.append(\"tuple\")\n            ret.append([self.wrap(i) for i in o])\n            return [index]\n        if o_t is bytes:\n            ret.append(\"bytes\")\n            ret.append([o[j] for j in range(len(o))])\n            return [index]\n        if o_t is list:\n            ret.append(\"list\")\n            ret.append([self.wrap(i) for i in o])\n            return [index]\n        if o_t is dict:\n            ret.append(\"dict\")\n            ret.append([[self.wrap(k), self.wrap(v)] for k,v in o.items()])\n            return [index]\n        \n        _0 = self._type_id(o_t)\n\n        if getattr(o_t, '__struct__', False):\n            ret.append(_0)\n            ret.append(o.tostruct().hex())\n            return [index]\n\n        if hasattr(o, \"__getnewargs__\"):\n            _1 = o.__getnewargs__()     # an iterable\n            _1 = [self.wrap(i) for i in _1]\n        else:\n            _1 = None\n\n        if o.__dict__ is None:\n            _2 = None\n        else:\n            _2 = {k: self.wrap(v) for k,v in o.__dict__.items()}\n\n        ret.append(_0)  # type id\n        ret.append(_1)  # newargs\n        ret.append(_2)  # state\n        return [index]\n    \n    def run_pipe(self):\n        o = self.wrap(self.obj)\n        return [o, self.memo]\n\n\n\nclass _Unpickler:\n    def __init__(self, obj, memo: list) -> None:\n        self.obj = obj\n        self.memo = memo\n        self._unwrapped = [None] * len(memo)\n\n    def tag(self, index, o):\n        assert self._unwrapped[index] is None\n        self._unwrapped[index] = o\n\n    def unwrap(self, o, index=None):\n        if type(o) in _BASIC_TYPES:\n            return o\n        assert type(o) is list\n\n        if o[0] == \"type\":\n            return _find_class(o[1])\n\n        # reference\n        if type(o[0]) is int:\n            assert index is None    # index should be None\n            index = o[0]\n            if self._unwrapped[index] is None:\n                o = self.memo[index]\n                assert type(o) is list\n                assert type(o[0]) is str\n                self.unwrap(o, index)\n                assert self._unwrapped[index] is not None\n            return self._unwrapped[index]\n        \n        # concrete reference type\n        if o[0] == \"tuple\":\n            ret = tuple([self.unwrap(i) for i in o[1]])\n            self.tag(index, ret)\n            return ret\n        if o[0] == \"bytes\":\n            ret = bytes(o[1])\n            self.tag(index, ret)\n            return ret\n        if o[0] == \"list\":\n            ret = []\n            self.tag(index, ret)\n            for i in o[1]:\n                ret.append(self.unwrap(i))\n            return ret\n        if o[0] == \"dict\":\n            ret = {}\n            self.tag(index, ret)\n            for k,v in o[1]:\n                ret[self.unwrap(k)] = self.unwrap(v)\n            return ret\n        \n        # generic object\n        cls = _find_class(o[0])\n        if getattr(cls, '__struct__', False):\n            inst = cls.fromstruct(struct.fromhex(o[1]))\n            self.tag(index, inst)\n            return inst\n        else:\n            _, newargs, state = o\n            # create uninitialized instance\n            new_f = getattr(cls, \"__new__\")\n            if newargs is not None:\n                newargs = [self.unwrap(i) for i in newargs]\n                inst = new_f(cls, *newargs)\n            else:\n                inst = new_f(cls)\n            self.tag(index, inst)\n            # restore state\n            if state is not None:\n                for k,v in state.items():\n                    setattr(inst, k, self.unwrap(v))\n            return inst\n\n    def run_pipe(self):\n        return self.unwrap(self.obj)\n\n\ndef _wrap(o):\n    return _Pickler(o).run_pipe()\n\ndef _unwrap(packed: list):\n    return _Unpickler(*packed).run_pipe()\n\ndef dumps(o) -> bytes:\n    o = _wrap(o)\n    return json.dumps(o).encode()\n\ndef loads(b) -> object:\n    assert type(b) is bytes\n    o = json.loads(b.decode())\n    return _unwrap(o)";
    const char kPythonLibs_this[] = "print(\"\"\"The Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\"\"\")";
    const char kPythonLibs_typing[] = "class _Placeholder:\n    def __init__(self, *args, **kwargs):\n        pass\n    def __getitem__(self, *args):\n        return self\n    def __call__(self, *args, **kwargs):\n        return self\n    def __and__(self, other):\n        return self\n    def __or__(self, other):\n        return self\n    def __xor__(self, other):\n        return self\n\n\n_PLACEHOLDER = _Placeholder()\n\nList = _PLACEHOLDER\nDict = _PLACEHOLDER\nTuple = _PLACEHOLDER\nSet = _PLACEHOLDER\nAny = _PLACEHOLDER\nUnion = _PLACEHOLDER\nOptional = _PLACEHOLDER\nCallable = _PLACEHOLDER\nType = _PLACEHOLDER\nProtocol = _PLACEHOLDER\n\nLiteral = _PLACEHOLDER\nLiteralString = _PLACEHOLDER\n\nIterable = _PLACEHOLDER\nGenerator = _PLACEHOLDER\n\nHashable = _PLACEHOLDER\n\nTypeVar = _PLACEHOLDER\nSelf = _PLACEHOLDER\n\nclass Generic:\n    pass\n\nTYPE_CHECKING = False\n\n# decorators\noverload = lambda x: x\nfinal = lambda x: x\n";
}    // namespace pkpy
